library('devtools')
devtools::install_github("usa-npn/rnpn")
# -----------------------------------
# NOTE: rnpn needs to be installed from GITHUB -- not CRAN!
#  i.e. you can NOT just do library('rnpn') -- you'll have an older version
# -----------------------------------
# install.packages("devtools")
# library('devtools')
# devtools::install_github("usa-npn/rnpn")
library(rnpn)
path.npn <- "../data_raw/NPN"
if(!dir.exists(path.npn)) dir.create(path.npn)
if(!dir.exists(file.path(path.npn, "npn_raw"))) dir.create(file.path(path.npn, "npn_raw"))
if(!dir.exists(file.path(path.npn, "summaries"))) dir.create(file.path(path.npn, "summaries"))
# -----------------------------------
# -----------------------------------
#npn_stations_with_spp
# Getting a list of all species
npn.spp <- npn_species()
npn.quercus <- npn.spp[npn.spp$genus=="Quercus",]
quercus.phenophase <- npn_get_phenophases_for_taxon(genus_ids=unique(npn.quercus$genus_id))
# To get pre-summarized data, use npn_donwload_individual_phenometrics
# to get help: ?npn_download_individual_phenometrics
# species_ids = what species you're interested in; just work with 1 at a time for now; can get rid of if you want everything from our Oak Collection
# station_ids=26202 gets just The Morton Arboretum Oak Collection (just for now)
# years = we can narrow this down, but we probably want everything we can get
# request_source = something the function needs so NPN knows whose using this
dat.npn <- npn_download_individual_phenometrics(species_ids=npn.quercus$species_id[npn.quercus$species=="alba"],
station_ids = 26202, years=2000:2020
, request_source="The Morton Arboretum")
dat.npn[dat.npn==-9999] <- NA
unique(dat.npn$phenophase_description)
summary(dat.npn)
# Note: this has more phenophases that we actually want right now, but lets just stick with it
write.csv(dat.npn, file.path(path.npn, "TEST_MortonArb_QUAL.csv"), row.names=F)
# Doing another quick search for the Arb, but getting everything from our oak collection; note that it is MUCH slower
# We're also only get a couple phenophases that we actually care about for this project
phenophase.leaves <- unique(dat.npn$phenophase_id[dat.npn$phenophase_description %in% c("Breaking leaf buds", "Leaves", "Falling leaves")])
# -----------------------------------
# NOTE: rnpn needs to be installed from GITHUB -- not CRAN!
#  i.e. you can NOT just do library('rnpn') -- you'll have an older version
# -----------------------------------
# install.packages("devtools")
# library('devtools')
devtools::install_github("usa-npn/rnpn")
# -----------------------------------
# NOTE: rnpn needs to be installed from GITHUB -- not CRAN!
#  i.e. you can NOT just do library('rnpn') -- you'll have an older version
# -----------------------------------
# install.packages("devtools")
# library('devtools')
devtools::install_github("usa-npn/rnpn")
install.packages(Rtools)
# -----------------------------------
# NOTE: rnpn needs to be installed from GITHUB -- not CRAN!
#  i.e. you can NOT just do library('rnpn') -- you'll have an older version
# -----------------------------------
# install.packages("devtools")
# library('devtools')
# devtools::install_github("usa-npn/rnpn")
library(rnpn)
path.npn <- "../data_raw/NPN"
if(!dir.exists(path.npn)) dir.create(path.npn)
if(!dir.exists(file.path(path.npn, "npn_raw"))) dir.create(file.path(path.npn, "npn_raw"))
if(!dir.exists(file.path(path.npn, "summaries"))) dir.create(file.path(path.npn, "summaries"))
# -----------------------------------
# -----------------------------------
#npn_stations_with_spp
# Getting a list of all species
npn.spp <- npn_species()
npn.quercus <- npn.spp[npn.spp$genus=="Quercus",]
quercus.phenophase <- npn_get_phenophases_for_taxon(genus_ids=unique(npn.quercus$genus_id))
# To get pre-summarized data, use npn_donwload_individual_phenometrics
# to get help: ?npn_download_individual_phenometrics
# species_ids = what species you're interested in; just work with 1 at a time for now; can get rid of if you want everything from our Oak Collection
# station_ids=26202 gets just The Morton Arboretum Oak Collection (just for now)
# years = we can narrow this down, but we probably want everything we can get
# request_source = something the function needs so NPN knows whose using this
dat.npn <- npn_download_individual_phenometrics(species_ids=npn.quercus$species_id[npn.quercus$species=="alba"],
station_ids = 26202, years=2000:2020
, request_source="The Morton Arboretum")
dat.npn[dat.npn==-9999] <- NA
unique(dat.npn$phenophase_description)
summary(dat.npn)
# Note: this has more phenophases that we actually want right now, but lets just stick with it
write.csv(dat.npn, file.path(path.npn, "TEST_MortonArb_QUAL.csv"), row.names=F)
# Doing another quick search for the Arb, but getting everything from our oak collection; note that it is MUCH slower
# We're also only get a couple phenophases that we actually care about for this project
phenophase.leaves <- unique(dat.npn$phenophase_id[dat.npn$phenophase_description %in% c("Breaking leaf buds", "Leaves", "Falling leaves")])
phenophase.leaves
oak.leaf <- npn_download_individual_phenometrics(phenophase_ids =c(371, 471, 483), station_ids = 26202, years=2000:2020, request_source="The Morton Arboretum")
oak.leaf[oak.leaf==-9999] <- NA
summary(oak.leaf)
dim(oak.leaf)
length(unique(oak.leaf$species)) # 12 unique species
length(unique(oak.leaf$individual_id)) # 31 unique trees
write.csv(oak.leaf, file.path(path.npn, "TEST_MortonArb_OakCollection_PhenoLeaf.csv"), row.names=F)
summary(dat.npn)
View(dat.npn)
#packages
#library(MODISTools)
#library(ggplot2)
#library(daymetr)
#library(xts)
#could be changed to be individual species not site
path.MODIS <- '../data_raw/MODIS'
site.id <- 'MortonArb'
dat.MODIS <- read.csv(file.path('../data_raw/MODIS', paste0("MODIS_Greenup_", site.id, ".csv")))
summary(dat.MODIS)
df.met <- read.csv(file.path('../data_raw/DAYMET', paste0("TEST_DAYMET_", site.id, ".csv")))
summary(df.met)
summary(df.met)
library(MODISTools)
library(ggplot2)
library(daymetr)
#could be changed to be individual species not site
path.MODIS <- '../data_raw/MODIS'
site.id <- 'MortonArb'
dat.MODIS <- read.csv(file.path('../data_raw/MODIS', paste0("MODIS_Greenup_", site.id, ".csv")))
summary(dat.MODIS)
df.met <- read.csv(file.path('../data_raw/DAYMET', paste0("TEST_DAYMET_", site.id, ".csv")))
summary(df.met)
for(i in 1:9){
# dat.MODIS[i,]
# We need to use greenup.year, greenup.yday
yr.now <- dat.MODIS[i, "greenup.year"] # same as dat.MODIS[i, "greenup.yr"]
yday.now <- dat.MODIS[i, "greenup.yday"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.MODIS row we're working with
dat.MODIS[i,"GDD5.cum"] <- df.met[df.met$year==yr.now & df.met$yday==yday.now,"GDD5.cum"]
}
head(dat.MODIS)
unique(dat.MODIS$BAND)
path.png <- '../data_raw/MODISMET'
png(filename= file.path(path.png, paste0('MODIS_Met_Plot_', site.id, '.png')))
ggplot(data = dat.MODIS, mapping = aes(x = BAND, y = GDD5.cum)) +
#facet_wrap(~BAND, scales="free") +
geom_boxplot()
ggplot(data = dat.MODIS, mapping = aes(x = BAND, y = GDD5.cum)) +
#facet_wrap(~BAND, scales="free") +
geom_point()
png(filename= file.path(path.png, paste0('MODIS_Met_Plot_', site.id, '.png')))
ggplot(data = dat.MODIS, mapping = aes(x = 'Greenup', y = GDD5.cum)) +
#facet_wrap(~BAND, scales="free") +
geom_point()
ggplot(data = dat.MODIS, mapping = aes(x = BAND, y = GDD5.cum)) +
facet_wrap(~BAND, scales="free") +
geom_point()
ggplot(data = dat.MODIS, mapping = aes(x = BAND, y = GDD5.cum)) +
facet_wrap(~BAND, scales="free") +
geom_point()
head(dat.MODIS)
View(dat.MODIS)
library(gglpot2)
library(ggplot2)
library(daymetr)
#get DAYMET data
site.id <- 'MortonArb'
df.met <- read.csv(file.path('../data_raw/DAYMET', paste0("TEST_DAYMET_", site.id, ".csv")))
summary(df.met)
#get NPN data
dat.npn <- read.csv(file.path('../data_raw/NPN', paste0("TEST_MortonArb_QUAL.csv")))
summary(dat.npn)
#----------------------------
head(dat.npn)
dat.npn$mean.phase <- (dat.npn$first_yes_doy + dat.npn$last_yes_doy)/2 #get a mean of each phenophase yday
#need to not take the gdd5 of all phenophases, but only breaking leaf buds
yday.burst <- dat.npn[dat.npn$phenophase_id == '371',]
head(yday.burst)
dat.npn$mean.bud <- round(x= dat.npn$mean.bud, digits = 0)
unique(dat.npn$individual_id)
summary(dat.npn$mean.bud)
for(i in 1:33){
# We need to use med.bud
bud.yday <- dat.npn[i, 'yday.bud']
bud.year <- dat.npn[i, "first_yes_year"]
bud.m <- dat.npn[i, "mean.phase"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.m, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
for(i in 1:3){
# We need to use med.bud
bud.yday <- dat.npn[i, 'yday.bud']
bud.year <- dat.npn[i, "first_yes_year"]
bud.m <- dat.npn[i, "mean.phase"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.m, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
#get DAYMET data
site.id <- 'MortonArb'
df.met <- read.csv(file.path('../data_raw/DAYMET', paste0("TEST_DAYMET_", site.id, ".csv")))
summary(df.met)
#get NPN data
dat.npn <- read.csv(file.path('../data_raw/NPN', paste0("TEST_MortonArb_QUAL.csv")))
summary(dat.npn)
#----------------------------
head(dat.npn)
dat.npn$mean.phase <- (dat.npn$first_yes_doy + dat.npn$last_yes_doy)/2 #get a mean of each phenophase yday
#need to not take the gdd5 of all phenophases, but only breaking leaf buds
yday.burst <- dat.npn[dat.npn$phenophase_id == '371',]
head(yday.burst)
dat.npn$mean.phase <- round(x= dat.npn$mean.phase, digits = 0)
unique(dat.npn$individual_id)
summary(dat.npn$mean.phase)
for(i in 1:3){
# We need to use med.bud
bud.yday <- dat.npn[i, 'yday.bud']
bud.year <- dat.npn[i, "first_yes_year"]
bud.m <- dat.npn[i, "mean.phase"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.m, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
library(ggplot2)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
facet_wrap(nrow= 1:3) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
facet_wrap(BAND, nrow= 1:3) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
facet_wrap(BAND, nrow= 3) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
facet_wrap(dat.npn$BAND, nrow= 3) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= yday.burst)) +
facet_wrap(dat.npn$BAND, nrow= 3) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= yday.burst)) +
geom_point()
View(dat.npn)
for(i in 1:3){
# We need to use med.bud
bud.yday <- dat.npn[i, 'yday.burst']
bud.year <- dat.npn[i, "first_yes_year"]
bud.m <- dat.npn[i, "mean.phase"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.m, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= yday.burst)) +
geom_point()
for(i in 1:3){
# We need to use med.bud
bud.yday <- dat.npn[i, 'mean.phase']
bud.year <- dat.npn[i, "first_yes_year"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.yday, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= yday.burst)) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_line()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_line(labels(dat.npn$mean.phase))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_line(mapping=aes(labels(dat.npn$mean.phase)))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_line()
head(dat.npn)
#need to not take the gdd5 of all phenophases, but only breaking leaf buds
dat.npn$yday.burst <- dat.npn[dat.npn$phenophase_id == '371',]
unique(dat.npn$individual_id)
for(i in 1:33){
# We need to use med.bud
bud.yday <- dat.npn[i, 'mean.phase']
bud.year <- dat.npn[i, "first_yes_year"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.yday, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_line()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
for(i in 0:3){
# We need to use med.bud
bud.yday <- dat.npn[i, 'mean.phase']
bud.year <- dat.npn[i, "first_yes_year"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.yday, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
for(i in 0:4){
# We need to use med.bud
bud.yday <- dat.npn[i, 'mean.phase']
bud.year <- dat.npn[i, "first_yes_year"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.yday, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
for(i in 1:3){
# We need to use med.bud
bud.yday <- dat.npn[i, 'mean.phase']
bud.year <- dat.npn[i, "first_yes_year"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.yday, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
library(ggplot2)
library(daymetr)
#get DAYMET data
site.id <- 'MortonArb'
df.met <- read.csv(file.path('../data_raw/DAYMET', paste0("TEST_DAYMET_", site.id, ".csv")))
summary(df.met)
#get NPN data
dat.npn <- read.csv(file.path('../data_raw/NPN', paste0("TEST_MortonArb_QUAL.csv")))
summary(dat.npn)
#----------------------------
head(dat.npn)
dat.npn$mean.phase <- (dat.npn$first_yes_doy + dat.npn$last_yes_doy)/2 #get a mean of each phenophase yday
#need to not take the gdd5 of all phenophases, but only breaking leaf buds
yday.burst <- dat.npn[dat.npn$phenophase_id == '371',]
head(yday.burst)
dat.npn$mean.phase <- round(x= dat.npn$mean.phase, digits = 0)
unique(dat.npn$individual_id)
summary(dat.npn$mean.phase)
for(i in 1:3){
# We need to use med.bud
bud.yday <- dat.npn[i, 'mean.phase']
bud.year <- dat.npn[i, "first_yes_year"]
# We need to get certain rows --> we need 2 pieces of info to match
#  we need BOTH year and yday to match that for the dat.npn row we're working with
dat.npn[i,"GDD5.cum"] <- df.met[df.met$year==bud.year & df.met$yday==bud.yday, "GDD5.cum"] #df.met$year==bud.year & df.met$yday==bud.m,
}
dat.npn$GDD5.cum <- round(x= dat.npn$GDD5.cum, digits = 0)
head(dat.npn)
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point()
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point(mapping = aes(color= 'individual_id'))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point(mapping = aes(color= individual_id))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point(mapping = aes(color= individual_id 'g'))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point(mapping = aes(color= individual_id, 'g'))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point(mapping = aes(color= individual_id,)) +
geom_point(mapping = aes(color = 'Idv. Tree ID'))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point(mapping = aes(color= individual_id)) +
geom_point(mapping = aes(color = 'Tree ID'))
ggplot(data = dat.npn, mapping = aes(x= GDD5.cum, y= mean.phase)) +
geom_point(mapping = aes(color= individual_id))
View(dat.npn)
View(df.met)
dat.d8 #see the temporal range of available data for this area. Should be from 2001 - 2017
#data from MODIS, MCD12Q2 found at https://lpdaac.usgs.gov/products/mcd12q2v006/
#----------------
#install.packages("MODISTools")
library(MODISTools)
#install.packages("ggplot2")
library(ggplot2)
#coordinates found from Google Earth of Andrew's Ivy Branch Farm
site.id <- 'MortonArb'
lat.in <- 41.813583
lon.in <- -88.052897
#set the data that we want specifically from MODISTools to prods
prods <- MODISTools::mt_products()
summary(prods)
prods$product
prods[prods$product == 'MCD12Q2',]
#showing only the bands of interest within the product 'MCD12Q2
mtbands <- MODISTools::mt_bands('MCD12Q2')
dim(mtbands)
#get list of dates for greenup
dat.d8 <- MODISTools::mt_dates('MCD12Q2', lat = lat.in, lon = lon.in)
dat.d8 #see the temporal range of available data for this area. Should be from 2001 - 2017
#This script will serve to download the daymet weather data for every location we use for a set of years
#Setting the points to download the daymet data from
path.daymet <- '../data_raw/DAYMET'
if(!dir.exists(path.daymet)) dir.create(path.daymet)
# Note: We will probably want this to go by species, rather than site, but for now this works
site.id = 'MortonArb'
# This will probably get changed to a list of sites that we have NPN data for for each species
dat.MODIS <- read.csv(file.path('../data_raw/MODIS', paste0("MODIS_Greenup_", site.id, ".csv")))
summary(dat.MODIS)
summary(dat.MODIS)
# Creating a point list and time range that matches your MODIS dataset
# Note: This will probably change down the road
modis.pts <- aggregate(greenup.year~site+latitude+longitude, data=dat.MODIS,
FUN=min)
names(modis.pts)[4] <- "yr.start"
modis.pts$yr.end <- aggregate(greenup.year~site+latitude+longitude, data=dat.MODIS,
FUN=max)[,4]
modis.pts
names(modis.pts)[4] <- "yr.start"
# if(!dir.exist(path.daymet)) dir.create(path.daymet)
#Downloading all of the daymet data for each point. Internal =TRUE means it creates a nested list. Set false to actually download a file
lat.list <- daymetr::download_daymet_batch(file_location = file.path(path.daymet, paste0("TEST_POINTS_", site.id, ".csv")),
start = 2017,
end = 2019,
internal = T)
View(lat.list)
# This gives us a list with one layer per site (I think)
length(lat.list)
names(lat.list) <- modis.pts$site # Giving the different layers of the list the site names they correspond to
# class(lat.list[[1]])
summary(lat.list[[1]])
summary(lat.list[[1]][["data"]]) # Lets us look at the data for the first site
#Lets look at the structure of what we are given
summary(lat.list)
#This is the general format
lat.list[[1]]$latitude
# Creating a new simplified list that won't make Christy cranky
list.met <- list()
for(i in seq_along(lat.list)){
list.met[[i]] <- data.frame(site=modis.pts$site[i], latitude=modis.pts$latitude[i], longitude=modis.pts$longitude[i], lat.list[[i]]$data)
}
names(list.met) <-  modis.pts$site
summary(list.met)
summary(list.met[[1]])
rm(lat.list) # Removing lat.list to save memory
summary(modis.pts)
View(lat.list)
# if(!dir.exist(path.daymet)) dir.create(path.daymet)
#Downloading all of the daymet data for each point. Internal =TRUE means it creates a nested list. Set false to actually download a file
lat.list <- daymetr::download_daymet_batch(file_location = file.path(path.daymet, paste0("TEST_POINTS_", site.id, ".csv")),
start = 2017,
end = 2019,
internal = T)
View(lat.list)
# This gives us a list with one layer per site (I think)
length(lat.list)
#names(lat.list) <- modis.pts$site # Giving the different layers of the list the site names they correspond to
# class(lat.list[[1]])
summary(lat.list[[1]])
summary(lat.list[[1]][["data"]]) # Lets us look at the data for the first site
#Lets look at the structure of what we are given
summary(lat.list)
#This is the general format
lat.list[[1]]$latitude
# Creating a new simplified list that won't make Christy cranky
list.met <- list()
for(i in seq_along(lat.list)){
list.met[[i]] <- data.frame(site=modis.pts$site[i], latitude=modis.pts$latitude[i], longitude=modis.pts$longitude[i], lat.list[[i]]$data)
}
#names(list.met) <-  modis.pts$site
summary(list.met)
summary(list.met[[1]])
rm(lat.list) # Removing lat.list to save memory
summary(list.met[[1]])
calc.gdd5 <- function(df.met){
df.met$Date <- as.Date(paste(df.met$year, df.met$yday, sep="-"), format="%Y-%j")
df.met$TMEAN <- (df.met$tmax..deg.c. + df.met$tmin..deg.c.)/2
df.met$GDD5 <- ifelse(df.met$TMEAN>5, df.met$TMEAN-5, 0)
df.met$GDD5.cum <- NA
for(YR in min(df.met$year):max(df.met$year)){
#df.yr is all weather data for a year at a location
df.yr <- df.met[df.met$year==YR,]
# Only calculate GDD5 if we have jan 1; this is Daymet, so it should be fine
if(min(df.yr$yday)==1){
# If we have Jan 1, calculate cumulative growing degree-days
df.yr$GDD5.cum <- cumsum(df.yr$GDD5)
} else {
# if we're missing Jan 1: still create the column, but don't fill it
df.yr$GDD5.cum <- NA
}
# Note: we could have done this differently,but :shrug: this is easier to diagnose
df.met[df.met$year==YR, "GDD5.cum"] <- df.yr$GDD5.cum
} # end year loop
return(df.met)
} # End funciton
# Apply our df.met function to all layers of our list;
# Note: we are overwriting the list, so be careful
list.met <- lapply(list.met, calc.gdd5)
summary(list.met[[1]])
# Unlist the met to save it to a dataframe that will be easier to share
df.met <- dplyr::bind_rows(list.met)
head(df.met)
View(df.met)
head(df.met)
# Quick graph to make sure things look okay
library(ggplot2)
ggplot(data=df.met) +
geom_line(aes(x=yday, y=GDD5.cum, group=year))
write.csv(df.met, file.path(path.daymet, paste0("TEST_DAYMET_", site.id, ".csv")), row.names=FALSE)
#get DAYMET data
site.id <- 'MortonArb'
df.met <- read.csv(file.path('../data_raw/DAYMET', paste0("TEST_DAYMET_", site.id, ".csv")))
summary(df.met)
